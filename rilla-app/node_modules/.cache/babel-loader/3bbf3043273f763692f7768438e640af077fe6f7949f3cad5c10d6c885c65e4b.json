{"ast":null,"code":"import { NumberValue } from \"./NumberValue\";\nexport const convertToAttr = (data, options) => {\n  if (data === undefined) {\n    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n  } else if (data === null && typeof data === \"object\") {\n    return convertToNullAttr();\n  } else if (Array.isArray(data)) {\n    return convertToListAttr(data, options);\n  } else if (data?.constructor?.name === \"Set\") {\n    return convertToSetAttr(data, options);\n  } else if (data?.constructor?.name === \"Map\") {\n    return convertToMapAttrFromIterable(data, options);\n  } else if (data?.constructor?.name === \"Object\" || !data.constructor && typeof data === \"object\") {\n    return convertToMapAttrFromEnumerableProps(data, options);\n  } else if (isBinary(data)) {\n    if (data.length === 0 && options?.convertEmptyValues) {\n      return convertToNullAttr();\n    }\n    return convertToBinaryAttr(data);\n  } else if (typeof data === \"boolean\" || data?.constructor?.name === \"Boolean\") {\n    return {\n      BOOL: data.valueOf()\n    };\n  } else if (typeof data === \"number\" || data?.constructor?.name === \"Number\") {\n    return convertToNumberAttr(data);\n  } else if (data instanceof NumberValue) {\n    return data.toAttributeValue();\n  } else if (typeof data === \"bigint\") {\n    return convertToBigIntAttr(data);\n  } else if (typeof data === \"string\" || data?.constructor?.name === \"String\") {\n    if (data.length === 0 && options?.convertEmptyValues) {\n      return convertToNullAttr();\n    }\n    return convertToStringAttr(data);\n  } else if (options?.convertClassInstanceToMap && typeof data === \"object\") {\n    return convertToMapAttrFromEnumerableProps(data, options);\n  }\n  throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);\n};\nconst convertToListAttr = (data, options) => ({\n  L: data.filter(item => typeof item !== \"function\" && (!options?.removeUndefinedValues || options?.removeUndefinedValues && item !== undefined)).map(item => convertToAttr(item, options))\n});\nconst convertToSetAttr = (set, options) => {\n  const setToOperate = options?.removeUndefinedValues ? new Set([...set].filter(value => value !== undefined)) : set;\n  if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {\n    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n  }\n  if (setToOperate.size === 0) {\n    if (options?.convertEmptyValues) {\n      return convertToNullAttr();\n    }\n    throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);\n  }\n  const item = setToOperate.values().next().value;\n  if (item instanceof NumberValue) {\n    return {\n      NS: Array.from(setToOperate).map(_ => _.toString())\n    };\n  } else if (typeof item === \"number\") {\n    return {\n      NS: Array.from(setToOperate).map(convertToNumberAttr).map(item => item.N)\n    };\n  } else if (typeof item === \"bigint\") {\n    return {\n      NS: Array.from(setToOperate).map(convertToBigIntAttr).map(item => item.N)\n    };\n  } else if (typeof item === \"string\") {\n    return {\n      SS: Array.from(setToOperate).map(convertToStringAttr).map(item => item.S)\n    };\n  } else if (isBinary(item)) {\n    return {\n      BS: Array.from(setToOperate).map(convertToBinaryAttr).map(item => item.B)\n    };\n  } else {\n    throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);\n  }\n};\nconst convertToMapAttrFromIterable = (data, options) => ({\n  M: (data => {\n    const map = {};\n    for (const [key, value] of data) {\n      if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n        map[key] = convertToAttr(value, options);\n      }\n    }\n    return map;\n  })(data)\n});\nconst convertToMapAttrFromEnumerableProps = (data, options) => ({\n  M: (data => {\n    const map = {};\n    for (const key in data) {\n      const value = data[key];\n      if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n        map[key] = convertToAttr(value, options);\n      }\n    }\n    return map;\n  })(data)\n});\nconst convertToNullAttr = () => ({\n  NULL: true\n});\nconst convertToBinaryAttr = data => ({\n  B: data\n});\nconst convertToStringAttr = data => ({\n  S: data.toString()\n});\nconst convertToBigIntAttr = data => ({\n  N: data.toString()\n});\nconst validateBigIntAndThrow = errorPrefix => {\n  throw new Error(`${errorPrefix} ${typeof BigInt === \"function\" ? \"Use BigInt.\" : \"Pass string value instead.\"} `);\n};\nconst convertToNumberAttr = num => {\n  if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY].map(val => val.toString()).includes(num.toString())) {\n    throw new Error(`Special numeric value ${num.toString()} is not allowed`);\n  } else if (num > Number.MAX_SAFE_INTEGER) {\n    validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);\n  } else if (num < Number.MIN_SAFE_INTEGER) {\n    validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);\n  }\n  return {\n    N: num.toString()\n  };\n};\nconst isBinary = data => {\n  const binaryTypes = [\"ArrayBuffer\", \"Blob\", \"Buffer\", \"DataView\", \"File\", \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\", \"BigInt64Array\", \"BigUint64Array\"];\n  if (data?.constructor) {\n    return binaryTypes.includes(data.constructor.name);\n  }\n  return false;\n};","map":{"version":3,"names":["NumberValue","convertToAttr","data","options","undefined","Error","convertToNullAttr","Array","isArray","convertToListAttr","constructor","name","convertToSetAttr","convertToMapAttrFromIterable","convertToMapAttrFromEnumerableProps","isBinary","length","convertEmptyValues","convertToBinaryAttr","BOOL","valueOf","convertToNumberAttr","toAttributeValue","convertToBigIntAttr","convertToStringAttr","convertClassInstanceToMap","L","filter","item","removeUndefinedValues","map","set","setToOperate","Set","value","has","size","values","next","NS","from","_","toString","N","SS","S","BS","B","M","key","NULL","validateBigIntAndThrow","errorPrefix","BigInt","num","Number","NaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","val","includes","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","binaryTypes"],"sources":["/Users/hamzahdeejay/Rilla-BackEnd/rilla-app/node_modules/@aws-sdk/util-dynamodb/dist-es/convertToAttr.js"],"sourcesContent":["import { NumberValue } from \"./NumberValue\";\nexport const convertToAttr = (data, options) => {\n    if (data === undefined) {\n        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n    }\n    else if (data === null && typeof data === \"object\") {\n        return convertToNullAttr();\n    }\n    else if (Array.isArray(data)) {\n        return convertToListAttr(data, options);\n    }\n    else if (data?.constructor?.name === \"Set\") {\n        return convertToSetAttr(data, options);\n    }\n    else if (data?.constructor?.name === \"Map\") {\n        return convertToMapAttrFromIterable(data, options);\n    }\n    else if (data?.constructor?.name === \"Object\" ||\n        (!data.constructor && typeof data === \"object\")) {\n        return convertToMapAttrFromEnumerableProps(data, options);\n    }\n    else if (isBinary(data)) {\n        if (data.length === 0 && options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        return convertToBinaryAttr(data);\n    }\n    else if (typeof data === \"boolean\" || data?.constructor?.name === \"Boolean\") {\n        return { BOOL: data.valueOf() };\n    }\n    else if (typeof data === \"number\" || data?.constructor?.name === \"Number\") {\n        return convertToNumberAttr(data);\n    }\n    else if (data instanceof NumberValue) {\n        return data.toAttributeValue();\n    }\n    else if (typeof data === \"bigint\") {\n        return convertToBigIntAttr(data);\n    }\n    else if (typeof data === \"string\" || data?.constructor?.name === \"String\") {\n        if (data.length === 0 && options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        return convertToStringAttr(data);\n    }\n    else if (options?.convertClassInstanceToMap && typeof data === \"object\") {\n        return convertToMapAttrFromEnumerableProps(data, options);\n    }\n    throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);\n};\nconst convertToListAttr = (data, options) => ({\n    L: data\n        .filter((item) => typeof item !== \"function\" &&\n        (!options?.removeUndefinedValues || (options?.removeUndefinedValues && item !== undefined)))\n        .map((item) => convertToAttr(item, options)),\n});\nconst convertToSetAttr = (set, options) => {\n    const setToOperate = options?.removeUndefinedValues ? new Set([...set].filter((value) => value !== undefined)) : set;\n    if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {\n        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n    }\n    if (setToOperate.size === 0) {\n        if (options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);\n    }\n    const item = setToOperate.values().next().value;\n    if (item instanceof NumberValue) {\n        return {\n            NS: Array.from(setToOperate).map((_) => _.toString()),\n        };\n    }\n    else if (typeof item === \"number\") {\n        return {\n            NS: Array.from(setToOperate)\n                .map(convertToNumberAttr)\n                .map((item) => item.N),\n        };\n    }\n    else if (typeof item === \"bigint\") {\n        return {\n            NS: Array.from(setToOperate)\n                .map(convertToBigIntAttr)\n                .map((item) => item.N),\n        };\n    }\n    else if (typeof item === \"string\") {\n        return {\n            SS: Array.from(setToOperate)\n                .map(convertToStringAttr)\n                .map((item) => item.S),\n        };\n    }\n    else if (isBinary(item)) {\n        return {\n            BS: Array.from(setToOperate)\n                .map(convertToBinaryAttr)\n                .map((item) => item.B),\n        };\n    }\n    else {\n        throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);\n    }\n};\nconst convertToMapAttrFromIterable = (data, options) => ({\n    M: ((data) => {\n        const map = {};\n        for (const [key, value] of data) {\n            if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n                map[key] = convertToAttr(value, options);\n            }\n        }\n        return map;\n    })(data),\n});\nconst convertToMapAttrFromEnumerableProps = (data, options) => ({\n    M: ((data) => {\n        const map = {};\n        for (const key in data) {\n            const value = data[key];\n            if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n                map[key] = convertToAttr(value, options);\n            }\n        }\n        return map;\n    })(data),\n});\nconst convertToNullAttr = () => ({ NULL: true });\nconst convertToBinaryAttr = (data) => ({ B: data });\nconst convertToStringAttr = (data) => ({ S: data.toString() });\nconst convertToBigIntAttr = (data) => ({ N: data.toString() });\nconst validateBigIntAndThrow = (errorPrefix) => {\n    throw new Error(`${errorPrefix} ${typeof BigInt === \"function\" ? \"Use BigInt.\" : \"Pass string value instead.\"} `);\n};\nconst convertToNumberAttr = (num) => {\n    if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]\n        .map((val) => val.toString())\n        .includes(num.toString())) {\n        throw new Error(`Special numeric value ${num.toString()} is not allowed`);\n    }\n    else if (num > Number.MAX_SAFE_INTEGER) {\n        validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);\n    }\n    else if (num < Number.MIN_SAFE_INTEGER) {\n        validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);\n    }\n    return { N: num.toString() };\n};\nconst isBinary = (data) => {\n    const binaryTypes = [\n        \"ArrayBuffer\",\n        \"Blob\",\n        \"Buffer\",\n        \"DataView\",\n        \"File\",\n        \"Int8Array\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"Int16Array\",\n        \"Uint16Array\",\n        \"Int32Array\",\n        \"Uint32Array\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n    ];\n    if (data?.constructor) {\n        return binaryTypes.includes(data.constructor.name);\n    }\n    return false;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}