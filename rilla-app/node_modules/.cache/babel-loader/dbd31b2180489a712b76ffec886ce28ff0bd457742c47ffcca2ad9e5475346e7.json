{"ast":null,"code":"import { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";\nexport const SELF = null;\nexport const ALL_VALUES = {};\nexport const ALL_MEMBERS = [];\nconst NEXT_LEVEL = \"*\";\nconst processObj = (obj, processFunc, keyNodes) => {\n  if (obj !== undefined) {\n    if (keyNodes == null) {\n      return processFunc(obj);\n    } else {\n      const keys = Object.keys(keyNodes);\n      const goToNextLevel = keys.length === 1 && keys[0] === NEXT_LEVEL;\n      const someChildren = keys.length >= 1 && !goToNextLevel;\n      const allChildren = keys.length === 0;\n      if (someChildren) {\n        return processKeysInObj(obj, processFunc, keyNodes);\n      } else if (allChildren) {\n        return processAllKeysInObj(obj, processFunc, SELF);\n      } else if (goToNextLevel) {\n        return Object.entries(obj ?? {}).reduce((acc, _ref) => {\n          let [k, v] = _ref;\n          if (typeof v !== \"function\") {\n            acc[k] = processObj(v, processFunc, keyNodes[NEXT_LEVEL]);\n          }\n          return acc;\n        }, Array.isArray(obj) ? [] : {});\n      }\n    }\n  }\n  return undefined;\n};\nconst processKeysInObj = (obj, processFunc, keyNodes) => {\n  let accumulator;\n  if (Array.isArray(obj)) {\n    accumulator = obj.filter(item => typeof item !== \"function\");\n  } else {\n    accumulator = {};\n    for (const [k, v] of Object.entries(obj)) {\n      if (typeof v !== \"function\") {\n        accumulator[k] = v;\n      }\n    }\n  }\n  for (const [nodeKey, nodes] of Object.entries(keyNodes)) {\n    if (typeof obj[nodeKey] === \"function\") {\n      continue;\n    }\n    const processedValue = processObj(obj[nodeKey], processFunc, nodes);\n    if (processedValue !== undefined && typeof processedValue !== \"function\") {\n      accumulator[nodeKey] = processedValue;\n    }\n  }\n  return accumulator;\n};\nconst processAllKeysInObj = (obj, processFunc, keyNodes) => {\n  if (Array.isArray(obj)) {\n    return obj.filter(item => typeof item !== \"function\").map(item => processObj(item, processFunc, keyNodes));\n  }\n  return Object.entries(obj).reduce((acc, _ref2) => {\n    let [key, value] = _ref2;\n    if (typeof value === \"function\") {\n      return acc;\n    }\n    const processedValue = processObj(value, processFunc, keyNodes);\n    if (processedValue !== undefined && typeof processedValue !== \"function\") {\n      acc[key] = processedValue;\n    }\n    return acc;\n  }, {});\n};\nexport const marshallInput = (obj, keyNodes, options) => {\n  const marshallFunc = toMarshall => marshall(toMarshall, options);\n  return processKeysInObj(obj, marshallFunc, keyNodes);\n};\nexport const unmarshallOutput = (obj, keyNodes, options) => {\n  const unmarshallFunc = toMarshall => unmarshall(toMarshall, options);\n  return processKeysInObj(obj, unmarshallFunc, keyNodes);\n};","map":{"version":3,"names":["marshall","unmarshall","SELF","ALL_VALUES","ALL_MEMBERS","NEXT_LEVEL","processObj","obj","processFunc","keyNodes","undefined","keys","Object","goToNextLevel","length","someChildren","allChildren","processKeysInObj","processAllKeysInObj","entries","reduce","acc","_ref","k","v","Array","isArray","accumulator","filter","item","nodeKey","nodes","processedValue","map","_ref2","key","value","marshallInput","options","marshallFunc","toMarshall","unmarshallOutput","unmarshallFunc"],"sources":["/Users/hamzahdeejay/Rilla-BackEnd/rilla-app/node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/utils.js"],"sourcesContent":["import { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";\nexport const SELF = null;\nexport const ALL_VALUES = {};\nexport const ALL_MEMBERS = [];\nconst NEXT_LEVEL = \"*\";\nconst processObj = (obj, processFunc, keyNodes) => {\n    if (obj !== undefined) {\n        if (keyNodes == null) {\n            return processFunc(obj);\n        }\n        else {\n            const keys = Object.keys(keyNodes);\n            const goToNextLevel = keys.length === 1 && keys[0] === NEXT_LEVEL;\n            const someChildren = keys.length >= 1 && !goToNextLevel;\n            const allChildren = keys.length === 0;\n            if (someChildren) {\n                return processKeysInObj(obj, processFunc, keyNodes);\n            }\n            else if (allChildren) {\n                return processAllKeysInObj(obj, processFunc, SELF);\n            }\n            else if (goToNextLevel) {\n                return Object.entries(obj ?? {}).reduce((acc, [k, v]) => {\n                    if (typeof v !== \"function\") {\n                        acc[k] = processObj(v, processFunc, keyNodes[NEXT_LEVEL]);\n                    }\n                    return acc;\n                }, (Array.isArray(obj) ? [] : {}));\n            }\n        }\n    }\n    return undefined;\n};\nconst processKeysInObj = (obj, processFunc, keyNodes) => {\n    let accumulator;\n    if (Array.isArray(obj)) {\n        accumulator = obj.filter((item) => typeof item !== \"function\");\n    }\n    else {\n        accumulator = {};\n        for (const [k, v] of Object.entries(obj)) {\n            if (typeof v !== \"function\") {\n                accumulator[k] = v;\n            }\n        }\n    }\n    for (const [nodeKey, nodes] of Object.entries(keyNodes)) {\n        if (typeof obj[nodeKey] === \"function\") {\n            continue;\n        }\n        const processedValue = processObj(obj[nodeKey], processFunc, nodes);\n        if (processedValue !== undefined && typeof processedValue !== \"function\") {\n            accumulator[nodeKey] = processedValue;\n        }\n    }\n    return accumulator;\n};\nconst processAllKeysInObj = (obj, processFunc, keyNodes) => {\n    if (Array.isArray(obj)) {\n        return obj.filter((item) => typeof item !== \"function\").map((item) => processObj(item, processFunc, keyNodes));\n    }\n    return Object.entries(obj).reduce((acc, [key, value]) => {\n        if (typeof value === \"function\") {\n            return acc;\n        }\n        const processedValue = processObj(value, processFunc, keyNodes);\n        if (processedValue !== undefined && typeof processedValue !== \"function\") {\n            acc[key] = processedValue;\n        }\n        return acc;\n    }, {});\n};\nexport const marshallInput = (obj, keyNodes, options) => {\n    const marshallFunc = (toMarshall) => marshall(toMarshall, options);\n    return processKeysInObj(obj, marshallFunc, keyNodes);\n};\nexport const unmarshallOutput = (obj, keyNodes, options) => {\n    const unmarshallFunc = (toMarshall) => unmarshall(toMarshall, options);\n    return processKeysInObj(obj, unmarshallFunc, keyNodes);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}