{"ast":null,"code":"const{DynamoDBClient}=require('@aws-sdk/client-dynamodb');const{DynamoDBDocumentClient,PutCommand,GetCommand,UpdateCommand,DeleteCommand,QueryCommand}=require('@aws-sdk/lib-dynamodb');const{S3Client,PutObjectCommand,GetObjectCommand,DeleteObjectCommand}=require(\"@aws-sdk/client-s3\");const axios=require('axios');const dynamoClient=new DynamoDBClient({});const docClient=DynamoDBDocumentClient.from(dynamoClient);const s3Client=new S3Client({region:\"us-west-1\"});async function main(event){const{httpMethod,body}=event;const parsedBody=JSON.parse(body);switch(httpMethod){case'POST':return await createComment(parsedBody);case'GET':if(parsedBody.transcriptId&&parsedBody.verify){return await verifyTranscriptContents(parsedBody.transcriptId);}else if(parsedBody.transcriptId){return await getAllCommentsForTranscript(parsedBody.transcriptId);}else if(parsedBody.commentId){return await getComment(parsedBody);}else{return{statusCode:400,body:JSON.stringify({message:'Missing transcriptId or commentId'})};}case'PUT':return await updateComment(parsedBody);case'DELETE':return await deleteComment(parsedBody);default:return{statusCode:400,body:JSON.stringify({message:'Unsupported HTTP method'})};}}exports.handler=async event=>{return await main(event);};async function createComment(body){const{transcriptId,userId,content,timestamp,fileAttachment}=body;const commentId=Date.now().toString();let fileKey;if(fileAttachment){fileKey=`attachments/${commentId}_${fileAttachment.name}`;await uploadFileToS3(fileKey,fileAttachment.content);}const newComment={commentId,userId,content,timestamp,fileAttachment:fileKey};try{var _currentTranscript$It;// Step 1: Get the current transcript\nconst getParams={TableName:'Transcripts',Key:{transcriptId}};const currentTranscript=await docClient.send(new GetCommand(getParams));let currentComments=((_currentTranscript$It=currentTranscript.Item)===null||_currentTranscript$It===void 0?void 0:_currentTranscript$It.comments)||'[]';// Parse the comments string to an array\nlet commentsArray;try{commentsArray=JSON.parse(currentComments);}catch(error){console.error('Error parsing comments:',error);commentsArray=[];}// Add the new comment\ncommentsArray.push(newComment);// Convert the array back to a string\nconst updatedCommentsString=JSON.stringify(commentsArray);// Step 2: Update the transcript with the new comments string\nconst transcriptParams={TableName:'Transcripts',Key:{transcriptId},UpdateExpression:'SET comments = :newComments',ExpressionAttributeValues:{':newComments':updatedCommentsString},ReturnValues:'UPDATED_NEW'};console.log('Updating transcript with params:',JSON.stringify(transcriptParams));const updateResult=await docClient.send(new UpdateCommand(transcriptParams));console.log('Transcript updated successfully. Result:',JSON.stringify(updateResult));return{statusCode:200,body:JSON.stringify({message:'Comment created and linked successfully',comment:newComment})};}catch(error){console.error('Error in createComment:',error);return{statusCode:500,body:JSON.stringify({message:'Error creating comment',error:error.message})};}}async function updateComment(body){const{commentId,content,fileAttachment}=body;let updateExpression='set content = :c';let expressionAttributeValues={':c':content};if(fileAttachment){const fileKey=`attachments/${commentId}_${fileAttachment.name}`;await uploadFileToS3(fileKey,fileAttachment.content);updateExpression+=', fileAttachment = :f';expressionAttributeValues[':f']=fileKey;}const params={TableName:'comments',Key:{commentId},UpdateExpression:updateExpression,ExpressionAttributeValues:expressionAttributeValues,ReturnValues:'UPDATED_NEW'};try{const result=await docClient.send(new UpdateCommand(params));return{statusCode:200,body:JSON.stringify({message:'Comment updated successfully',updatedAttributes:result.Attributes})};}catch(error){console.error('Error updating comment:',error);return{statusCode:500,body:JSON.stringify({message:'Error updating comment',error:error.message})};}}async function deleteComment(body){const{commentId}=body;const params={TableName:'comments',Key:{commentId},ReturnValues:'ALL_OLD'};try{const result=await docClient.send(new DeleteCommand(params));if(result.Attributes&&result.Attributes.fileAttachment){await deleteFileFromS3(result.Attributes.fileAttachment);}return{statusCode:200,body:JSON.stringify({message:'Comment deleted successfully'})};}catch(error){console.error('Error deleting comment:',error);return{statusCode:500,body:JSON.stringify({message:'Error deleting comment',error:error.message})};}}async function verifyTranscriptContents(transcriptId){const params={TableName:'Transcripts',Key:{transcriptId}};try{const result=await docClient.send(new GetCommand(params));console.log('Transcript contents:',JSON.stringify(result.Item,null,2));if(result.Item&&result.Item.comments){console.log('Comments type:',typeof result.Item.comments);let commentsArray;try{commentsArray=JSON.parse(result.Item.comments);console.log('Parsed comments is array:',Array.isArray(commentsArray));console.log('Parsed comments length:',commentsArray.length);console.log('First 5 comments:',commentsArray.slice(0,5));}catch(error){console.error('Error parsing comments:',error);console.log('Raw comments value:',result.Item.comments);}}else{console.log('No comments found or comments is not a string');}return{statusCode:200,body:JSON.stringify(result.Item)};}catch(error){console.error('Error verifying transcript contents:',error);return{statusCode:500,body:JSON.stringify({message:'Error verifying transcript',error:error.message})};}}async function getAllCommentsForTranscript(transcriptId){try{const params={TableName:'Transcripts',Key:{transcriptId}};const result=await docClient.send(new GetCommand(params));let comments=[];if(result.Item&&result.Item.comments){try{comments=JSON.parse(result.Item.comments);}catch(error){console.error('Error parsing comments:',error);}}return{statusCode:200,body:JSON.stringify(comments)};}catch(error){console.error('Error getting comments for transcript:',error);return{statusCode:500,body:JSON.stringify({message:'Error getting comments',error:error.message})};}}async function uploadFileToS3(key,content){const params={Bucket:\"filesrilla\",Key:key,Body:Buffer.from(content,'base64'),ContentType:\"application/octet-stream\"};await s3Client.send(new PutObjectCommand(params));}async function deleteFileFromS3(key){const params={Bucket:\"filesrilla\",Key:key};await s3Client.send(new DeleteObjectCommand(params));}async function getComment(body){// Implement this function\n}async function sendTranscriptToOpenAI(data){try{const response=await axios.post('YOUR_OPENAI_API_ENDPOINT',data);return response;}catch(error){console.error('Error sending transcript to OpenAI:',error);throw error;}}","map":{"version":3,"names":["DynamoDBClient","require","DynamoDBDocumentClient","PutCommand","GetCommand","UpdateCommand","DeleteCommand","QueryCommand","S3Client","PutObjectCommand","GetObjectCommand","DeleteObjectCommand","axios","dynamoClient","docClient","from","s3Client","region","main","event","httpMethod","body","parsedBody","JSON","parse","createComment","transcriptId","verify","verifyTranscriptContents","getAllCommentsForTranscript","commentId","getComment","statusCode","stringify","message","updateComment","deleteComment","exports","handler","userId","content","timestamp","fileAttachment","Date","now","toString","fileKey","name","uploadFileToS3","newComment","_currentTranscript$It","getParams","TableName","Key","currentTranscript","send","currentComments","Item","comments","commentsArray","error","console","push","updatedCommentsString","transcriptParams","UpdateExpression","ExpressionAttributeValues","ReturnValues","log","updateResult","comment","updateExpression","expressionAttributeValues","params","result","updatedAttributes","Attributes","deleteFileFromS3","Array","isArray","length","slice","key","Bucket","Body","Buffer","ContentType","sendTranscriptToOpenAI","data","response","post"],"sources":["/Users/hamzahdeejay/Rilla-BackEnd/rilla-app/src/index.js"],"sourcesContent":["const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');\nconst { DynamoDBDocumentClient, PutCommand, GetCommand, UpdateCommand, DeleteCommand, QueryCommand } = require('@aws-sdk/lib-dynamodb');\nconst { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } = require(\"@aws-sdk/client-s3\");\nconst axios = require('axios');\n\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\nconst s3Client = new S3Client({ region: \"us-west-1\" }); \n\nasync function main(event) {\n  const { httpMethod, body } = event;\n  const parsedBody = JSON.parse(body);\n\n  switch (httpMethod) {\n    case 'POST':\n      return await createComment(parsedBody);\n    case 'GET':\n      if (parsedBody.transcriptId && parsedBody.verify) {\n        return await verifyTranscriptContents(parsedBody.transcriptId);\n      } else if (parsedBody.transcriptId) {\n        return await getAllCommentsForTranscript(parsedBody.transcriptId);\n      } else if (parsedBody.commentId) {\n        return await getComment(parsedBody);\n      } else {\n        return {\n          statusCode: 400,\n          body: JSON.stringify({ message: 'Missing transcriptId or commentId' })\n        };\n      }\n    case 'PUT':\n      return await updateComment(parsedBody);\n    case 'DELETE':\n      return await deleteComment(parsedBody);\n    default:\n      return {\n        statusCode: 400,\n        body: JSON.stringify({ message: 'Unsupported HTTP method' })\n      };\n  }\n}\n\nexports.handler = async (event) => {\n  return await main(event);\n};\n\nasync function createComment(body) {\n  const { transcriptId, userId, content, timestamp, fileAttachment } = body;\n  \n  const commentId = Date.now().toString();\n  let fileKey;\n\n  if (fileAttachment) {\n    fileKey = `attachments/${commentId}_${fileAttachment.name}`;\n    await uploadFileToS3(fileKey, fileAttachment.content);\n  }\n\n  const newComment = {\n    commentId,\n    userId,\n    content,\n    timestamp,\n    fileAttachment: fileKey\n  };\n\n  try {\n    // Step 1: Get the current transcript\n    const getParams = {\n      TableName: 'Transcripts',\n      Key: { transcriptId }\n    };\n    const currentTranscript = await docClient.send(new GetCommand(getParams));\n    let currentComments = currentTranscript.Item?.comments || '[]';\n\n    // Parse the comments string to an array\n    let commentsArray;\n    try {\n      commentsArray = JSON.parse(currentComments);\n    } catch (error) {\n      console.error('Error parsing comments:', error);\n      commentsArray = [];\n    }\n\n    // Add the new comment\n    commentsArray.push(newComment);\n\n    // Convert the array back to a string\n    const updatedCommentsString = JSON.stringify(commentsArray);\n\n    // Step 2: Update the transcript with the new comments string\n    const transcriptParams = {\n      TableName: 'Transcripts',\n      Key: { transcriptId },\n      UpdateExpression: 'SET comments = :newComments',\n      ExpressionAttributeValues: {\n        ':newComments': updatedCommentsString\n      },\n      ReturnValues: 'UPDATED_NEW'\n    };\n\n    console.log('Updating transcript with params:', JSON.stringify(transcriptParams));\n    const updateResult = await docClient.send(new UpdateCommand(transcriptParams));\n    console.log('Transcript updated successfully. Result:', JSON.stringify(updateResult));\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Comment created and linked successfully', comment: newComment })\n    };\n  } catch (error) {\n    console.error('Error in createComment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error creating comment', error: error.message })\n    };\n  }\n}\n\nasync function updateComment(body) {\n  const { commentId, content, fileAttachment } = body;\n  \n  let updateExpression = 'set content = :c';\n  let expressionAttributeValues = { ':c': content };\n\n  if (fileAttachment) {\n    const fileKey = `attachments/${commentId}_${fileAttachment.name}`;\n    await uploadFileToS3(fileKey, fileAttachment.content);\n    updateExpression += ', fileAttachment = :f';\n    expressionAttributeValues[':f'] = fileKey;\n  }\n\n  const params = {\n    TableName: 'comments',\n    Key: { commentId },\n    UpdateExpression: updateExpression,\n    ExpressionAttributeValues: expressionAttributeValues,\n    ReturnValues: 'UPDATED_NEW'\n  };\n  \n  try {\n    const result = await docClient.send(new UpdateCommand(params));\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Comment updated successfully', updatedAttributes: result.Attributes })\n    };\n  } catch (error) {\n    console.error('Error updating comment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error updating comment', error: error.message })\n    };\n  }\n}\n\nasync function deleteComment(body) {\n  const { commentId } = body;\n  \n  const params = {\n    TableName: 'comments',\n    Key: { commentId },\n    ReturnValues: 'ALL_OLD'\n  };\n  \n  try {\n    const result = await docClient.send(new DeleteCommand(params));\n    if (result.Attributes && result.Attributes.fileAttachment) {\n      await deleteFileFromS3(result.Attributes.fileAttachment);\n    }\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Comment deleted successfully' })\n    };\n  } catch (error) {\n    console.error('Error deleting comment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error deleting comment', error: error.message })\n    };\n  }\n}\n\nasync function verifyTranscriptContents(transcriptId) {\n  const params = {\n    TableName: 'Transcripts',\n    Key: { transcriptId }\n  };\n\n  try {\n    const result = await docClient.send(new GetCommand(params));\n    console.log('Transcript contents:', JSON.stringify(result.Item, null, 2));\n    \n    if (result.Item && result.Item.comments) {\n      console.log('Comments type:', typeof result.Item.comments);\n      let commentsArray;\n      try {\n        commentsArray = JSON.parse(result.Item.comments);\n        console.log('Parsed comments is array:', Array.isArray(commentsArray));\n        console.log('Parsed comments length:', commentsArray.length);\n        console.log('First 5 comments:', commentsArray.slice(0, 5));\n      } catch (error) {\n        console.error('Error parsing comments:', error);\n        console.log('Raw comments value:', result.Item.comments);\n      }\n    } else {\n      console.log('No comments found or comments is not a string');\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify(result.Item)\n    };\n  } catch (error) {\n    console.error('Error verifying transcript contents:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error verifying transcript', error: error.message })\n    };\n  }\n}\n\nasync function getAllCommentsForTranscript(transcriptId) {\n  try {\n    const params = {\n      TableName: 'Transcripts',\n      Key: { transcriptId }\n    };\n    const result = await docClient.send(new GetCommand(params));\n    \n    let comments = [];\n    if (result.Item && result.Item.comments) {\n      try {\n        comments = JSON.parse(result.Item.comments);\n      } catch (error) {\n        console.error('Error parsing comments:', error);\n      }\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify(comments)\n    };\n  } catch (error) {\n    console.error('Error getting comments for transcript:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error getting comments', error: error.message })\n    };\n  }\n}\n\nasync function uploadFileToS3(key, content) {\n  const params = {\n    Bucket: \"filesrilla\",\n    Key: key,\n    Body: Buffer.from(content, 'base64'),\n    ContentType: \"application/octet-stream\"\n  };\n\n  await s3Client.send(new PutObjectCommand(params));\n}\n\nasync function deleteFileFromS3(key) {\n  const params = {\n    Bucket: \"filesrilla\", \n    Key: key\n  };\n\n  await s3Client.send(new DeleteObjectCommand(params));\n}\n\nasync function getComment(body) {\n  // Implement this function\n}\n\nasync function sendTranscriptToOpenAI(data) {\n  try {\n    const response = await axios.post('YOUR_OPENAI_API_ENDPOINT', data);\n    return response;\n  } catch (error) {\n    console.error('Error sending transcript to OpenAI:', error);\n    throw error;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}