{"ast":null,"code":"import { NumberValue } from \"./NumberValue\";\nexport const convertToNative = (data, options) => {\n  for (const [key, value] of Object.entries(data)) {\n    if (value !== undefined) {\n      switch (key) {\n        case \"NULL\":\n          return null;\n        case \"BOOL\":\n          return Boolean(value);\n        case \"N\":\n          return convertNumber(value, options);\n        case \"B\":\n          return convertBinary(value);\n        case \"S\":\n          return convertString(value);\n        case \"L\":\n          return convertList(value, options);\n        case \"M\":\n          return convertMap(value, options);\n        case \"NS\":\n          return new Set(value.map(item => convertNumber(item, options)));\n        case \"BS\":\n          return new Set(value.map(convertBinary));\n        case \"SS\":\n          return new Set(value.map(convertString));\n        default:\n          throw new Error(`Unsupported type passed: ${key}`);\n      }\n    }\n  }\n  throw new Error(`No value defined: ${JSON.stringify(data)}`);\n};\nconst convertNumber = (numString, options) => {\n  if (options?.wrapNumbers) {\n    return NumberValue.from(numString);\n  }\n  const num = Number(numString);\n  const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n  const isLargeFiniteNumber = (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num);\n  if (isLargeFiniteNumber) {\n    if (typeof BigInt === \"function\") {\n      try {\n        return BigInt(numString);\n      } catch (error) {\n        throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);\n      }\n    } else {\n      throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);\n    }\n  }\n  return num;\n};\nconst convertString = stringValue => stringValue;\nconst convertBinary = binaryValue => binaryValue;\nconst convertList = (list, options) => list.map(item => convertToNative(item, options));\nconst convertMap = (map, options) => Object.entries(map).reduce((acc, _ref) => {\n  let [key, value] = _ref;\n  return acc[key] = convertToNative(value, options), acc;\n}, {});","map":{"version":3,"names":["NumberValue","convertToNative","data","options","key","value","Object","entries","undefined","Boolean","convertNumber","convertBinary","convertString","convertList","convertMap","Set","map","item","Error","JSON","stringify","numString","wrapNumbers","from","num","Number","infinityValues","POSITIVE_INFINITY","NEGATIVE_INFINITY","isLargeFiniteNumber","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","includes","BigInt","error","stringValue","binaryValue","list","reduce","acc","_ref"],"sources":["/Users/hamzahdeejay/Rilla-BackEnd/rilla-app/node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js"],"sourcesContent":["import { NumberValue } from \"./NumberValue\";\nexport const convertToNative = (data, options) => {\n    for (const [key, value] of Object.entries(data)) {\n        if (value !== undefined) {\n            switch (key) {\n                case \"NULL\":\n                    return null;\n                case \"BOOL\":\n                    return Boolean(value);\n                case \"N\":\n                    return convertNumber(value, options);\n                case \"B\":\n                    return convertBinary(value);\n                case \"S\":\n                    return convertString(value);\n                case \"L\":\n                    return convertList(value, options);\n                case \"M\":\n                    return convertMap(value, options);\n                case \"NS\":\n                    return new Set(value.map((item) => convertNumber(item, options)));\n                case \"BS\":\n                    return new Set(value.map(convertBinary));\n                case \"SS\":\n                    return new Set(value.map(convertString));\n                default:\n                    throw new Error(`Unsupported type passed: ${key}`);\n            }\n        }\n    }\n    throw new Error(`No value defined: ${JSON.stringify(data)}`);\n};\nconst convertNumber = (numString, options) => {\n    if (options?.wrapNumbers) {\n        return NumberValue.from(numString);\n    }\n    const num = Number(numString);\n    const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    const isLargeFiniteNumber = (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num);\n    if (isLargeFiniteNumber) {\n        if (typeof BigInt === \"function\") {\n            try {\n                return BigInt(numString);\n            }\n            catch (error) {\n                throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);\n            }\n        }\n        else {\n            throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);\n        }\n    }\n    return num;\n};\nconst convertString = (stringValue) => stringValue;\nconst convertBinary = (binaryValue) => binaryValue;\nconst convertList = (list, options) => list.map((item) => convertToNative(item, options));\nconst convertMap = (map, options) => Object.entries(map).reduce((acc, [key, value]) => ((acc[key] = convertToNative(value, options)), acc), {});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}