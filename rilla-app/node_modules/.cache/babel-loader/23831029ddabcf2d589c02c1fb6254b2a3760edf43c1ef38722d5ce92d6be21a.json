{"ast":null,"code":"const requestQueue = {};\nexport const updateDiscoveredEndpointInCache = async (config, options) => new Promise((resolve, reject) => {\n  const {\n    endpointCache\n  } = config;\n  const {\n    cacheKey,\n    commandName,\n    identifiers\n  } = options;\n  const endpoints = endpointCache.get(cacheKey);\n  if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n    if (options.isDiscoveredEndpointRequired) {\n      if (!requestQueue[cacheKey]) requestQueue[cacheKey] = [];\n      requestQueue[cacheKey].push({\n        resolve,\n        reject\n      });\n    } else {\n      resolve();\n    }\n  } else if (endpoints && endpoints.length > 0) {\n    resolve();\n  } else {\n    const placeholderEndpoints = [{\n      Address: \"\",\n      CachePeriodInMinutes: 1\n    }];\n    endpointCache.set(cacheKey, placeholderEndpoints);\n    const command = new options.endpointDiscoveryCommandCtor({\n      Operation: commandName.slice(0, -7),\n      Identifiers: identifiers\n    });\n    const handler = command.resolveMiddleware(options.clientStack, config, options.options);\n    handler(command).then(result => {\n      endpointCache.set(cacheKey, result.output.Endpoints);\n      if (requestQueue[cacheKey]) {\n        requestQueue[cacheKey].forEach(_ref => {\n          let {\n            resolve\n          } = _ref;\n          resolve();\n        });\n        delete requestQueue[cacheKey];\n      }\n      resolve();\n    }).catch(error => {\n      endpointCache.delete(cacheKey);\n      const errorToThrow = Object.assign(new Error(`The operation to discover endpoint failed.` + ` Please retry, or provide a custom endpoint and disable endpoint discovery to proceed.`), {\n        reason: error\n      });\n      if (requestQueue[cacheKey]) {\n        requestQueue[cacheKey].forEach(_ref2 => {\n          let {\n            reject\n          } = _ref2;\n          reject(errorToThrow);\n        });\n        delete requestQueue[cacheKey];\n      }\n      if (options.isDiscoveredEndpointRequired) {\n        reject(errorToThrow);\n      } else {\n        endpointCache.set(cacheKey, placeholderEndpoints);\n        resolve();\n      }\n    });\n  }\n});","map":{"version":3,"names":["requestQueue","updateDiscoveredEndpointInCache","config","options","Promise","resolve","reject","endpointCache","cacheKey","commandName","identifiers","endpoints","get","length","Address","isDiscoveredEndpointRequired","push","placeholderEndpoints","CachePeriodInMinutes","set","command","endpointDiscoveryCommandCtor","Operation","slice","Identifiers","handler","resolveMiddleware","clientStack","then","result","output","Endpoints","forEach","_ref","catch","error","delete","errorToThrow","Object","assign","Error","reason","_ref2"],"sources":["/Users/hamzahdeejay/Rilla-BackEnd/rilla-app/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/updateDiscoveredEndpointInCache.js"],"sourcesContent":["const requestQueue = {};\nexport const updateDiscoveredEndpointInCache = async (config, options) => new Promise((resolve, reject) => {\n    const { endpointCache } = config;\n    const { cacheKey, commandName, identifiers } = options;\n    const endpoints = endpointCache.get(cacheKey);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        if (options.isDiscoveredEndpointRequired) {\n            if (!requestQueue[cacheKey])\n                requestQueue[cacheKey] = [];\n            requestQueue[cacheKey].push({ resolve, reject });\n        }\n        else {\n            resolve();\n        }\n    }\n    else if (endpoints && endpoints.length > 0) {\n        resolve();\n    }\n    else {\n        const placeholderEndpoints = [{ Address: \"\", CachePeriodInMinutes: 1 }];\n        endpointCache.set(cacheKey, placeholderEndpoints);\n        const command = new options.endpointDiscoveryCommandCtor({\n            Operation: commandName.slice(0, -7),\n            Identifiers: identifiers,\n        });\n        const handler = command.resolveMiddleware(options.clientStack, config, options.options);\n        handler(command)\n            .then((result) => {\n            endpointCache.set(cacheKey, result.output.Endpoints);\n            if (requestQueue[cacheKey]) {\n                requestQueue[cacheKey].forEach(({ resolve }) => {\n                    resolve();\n                });\n                delete requestQueue[cacheKey];\n            }\n            resolve();\n        })\n            .catch((error) => {\n            endpointCache.delete(cacheKey);\n            const errorToThrow = Object.assign(new Error(`The operation to discover endpoint failed.` +\n                ` Please retry, or provide a custom endpoint and disable endpoint discovery to proceed.`), { reason: error });\n            if (requestQueue[cacheKey]) {\n                requestQueue[cacheKey].forEach(({ reject }) => {\n                    reject(errorToThrow);\n                });\n                delete requestQueue[cacheKey];\n            }\n            if (options.isDiscoveredEndpointRequired) {\n                reject(errorToThrow);\n            }\n            else {\n                endpointCache.set(cacheKey, placeholderEndpoints);\n                resolve();\n            }\n        });\n    }\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}