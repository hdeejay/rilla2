{"ast":null,"code":"const {\n  DynamoDBClient\n} = require('@aws-sdk/client-dynamodb');\nconst {\n  DynamoDBDocumentClient,\n  PutCommand,\n  GetCommand,\n  UpdateCommand,\n  DeleteCommand,\n  QueryCommand\n} = require('@aws-sdk/lib-dynamodb');\nconst {\n  S3Client,\n  PutObjectCommand,\n  GetObjectCommand,\n  DeleteObjectCommand\n} = require(\"@aws-sdk/client-s3\");\nconst axios = require('axios');\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\nconst s3Client = new S3Client({\n  region: \"us-west-1\"\n});\nasync function main(event) {\n  const {\n    httpMethod,\n    body\n  } = event;\n  const parsedBody = JSON.parse(body);\n  switch (httpMethod) {\n    case 'POST':\n      return await createComment(parsedBody);\n    case 'GET':\n      if (parsedBody.transcriptId && parsedBody.verify) {\n        return await verifyTranscriptContents(parsedBody.transcriptId);\n      } else if (parsedBody.transcriptId) {\n        return await getAllCommentsForTranscript(parsedBody.transcriptId);\n      } else if (parsedBody.commentId) {\n        return await getComment(parsedBody);\n      } else {\n        return {\n          statusCode: 400,\n          body: JSON.stringify({\n            message: 'Missing transcriptId or commentId'\n          })\n        };\n      }\n    case 'PUT':\n      return await updateComment(parsedBody);\n    case 'DELETE':\n      return await deleteComment(parsedBody);\n    default:\n      return {\n        statusCode: 400,\n        body: JSON.stringify({\n          message: 'Unsupported HTTP method'\n        })\n      };\n  }\n}\nexports.handler = async event => {\n  return await main(event);\n};\nasync function createComment(body) {\n  const {\n    transcriptId,\n    userId,\n    content,\n    timestamp,\n    fileAttachment\n  } = body;\n  const commentId = Date.now().toString();\n  let fileKey;\n  if (fileAttachment) {\n    fileKey = `attachments/${commentId}_${fileAttachment.name}`;\n    await uploadFileToS3(fileKey, fileAttachment.content);\n  }\n  const newComment = {\n    commentId,\n    userId,\n    content,\n    timestamp,\n    fileAttachment: fileKey\n  };\n  try {\n    var _currentTranscript$It;\n    // Step 1: Get the current transcript\n    const getParams = {\n      TableName: 'Transcripts',\n      Key: {\n        transcriptId\n      }\n    };\n    const currentTranscript = await docClient.send(new GetCommand(getParams));\n    let currentComments = ((_currentTranscript$It = currentTranscript.Item) === null || _currentTranscript$It === void 0 ? void 0 : _currentTranscript$It.comments) || '[]';\n\n    // Parse the comments string to an array\n    let commentsArray;\n    try {\n      commentsArray = JSON.parse(currentComments);\n    } catch (error) {\n      console.error('Error parsing comments:', error);\n      commentsArray = [];\n    }\n\n    // Add the new comment\n    commentsArray.push(newComment);\n\n    // Convert the array back to a string\n    const updatedCommentsString = JSON.stringify(commentsArray);\n\n    // Step 2: Update the transcript with the new comments string\n    const transcriptParams = {\n      TableName: 'Transcripts',\n      Key: {\n        transcriptId\n      },\n      UpdateExpression: 'SET comments = :newComments',\n      ExpressionAttributeValues: {\n        ':newComments': updatedCommentsString\n      },\n      ReturnValues: 'UPDATED_NEW'\n    };\n    console.log('Updating transcript with params:', JSON.stringify(transcriptParams));\n    const updateResult = await docClient.send(new UpdateCommand(transcriptParams));\n    console.log('Transcript updated successfully. Result:', JSON.stringify(updateResult));\n    return {\n      statusCode: 200,\n      body: JSON.stringify({\n        message: 'Comment created and linked successfully',\n        comment: newComment\n      })\n    };\n  } catch (error) {\n    console.error('Error in createComment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        message: 'Error creating comment',\n        error: error.message\n      })\n    };\n  }\n}\nasync function updateComment(body) {\n  const {\n    commentId,\n    content,\n    fileAttachment\n  } = body;\n  let updateExpression = 'set content = :c';\n  let expressionAttributeValues = {\n    ':c': content\n  };\n  if (fileAttachment) {\n    const fileKey = `attachments/${commentId}_${fileAttachment.name}`;\n    await uploadFileToS3(fileKey, fileAttachment.content);\n    updateExpression += ', fileAttachment = :f';\n    expressionAttributeValues[':f'] = fileKey;\n  }\n  const params = {\n    TableName: 'comments',\n    Key: {\n      commentId\n    },\n    UpdateExpression: updateExpression,\n    ExpressionAttributeValues: expressionAttributeValues,\n    ReturnValues: 'UPDATED_NEW'\n  };\n  try {\n    const result = await docClient.send(new UpdateCommand(params));\n    return {\n      statusCode: 200,\n      body: JSON.stringify({\n        message: 'Comment updated successfully',\n        updatedAttributes: result.Attributes\n      })\n    };\n  } catch (error) {\n    console.error('Error updating comment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        message: 'Error updating comment',\n        error: error.message\n      })\n    };\n  }\n}\nasync function deleteComment(body) {\n  const {\n    commentId\n  } = body;\n  const params = {\n    TableName: 'comments',\n    Key: {\n      commentId\n    },\n    ReturnValues: 'ALL_OLD'\n  };\n  try {\n    const result = await docClient.send(new DeleteCommand(params));\n    if (result.Attributes && result.Attributes.fileAttachment) {\n      await deleteFileFromS3(result.Attributes.fileAttachment);\n    }\n    return {\n      statusCode: 200,\n      body: JSON.stringify({\n        message: 'Comment deleted successfully'\n      })\n    };\n  } catch (error) {\n    console.error('Error deleting comment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        message: 'Error deleting comment',\n        error: error.message\n      })\n    };\n  }\n}\nasync function verifyTranscriptContents(transcriptId) {\n  const params = {\n    TableName: 'Transcripts',\n    Key: {\n      transcriptId\n    }\n  };\n  try {\n    const result = await docClient.send(new GetCommand(params));\n    console.log('Transcript contents:', JSON.stringify(result.Item, null, 2));\n    if (result.Item && result.Item.comments) {\n      console.log('Comments type:', typeof result.Item.comments);\n      let commentsArray;\n      try {\n        commentsArray = JSON.parse(result.Item.comments);\n        console.log('Parsed comments is array:', Array.isArray(commentsArray));\n        console.log('Parsed comments length:', commentsArray.length);\n        console.log('First 5 comments:', commentsArray.slice(0, 5));\n      } catch (error) {\n        console.error('Error parsing comments:', error);\n        console.log('Raw comments value:', result.Item.comments);\n      }\n    } else {\n      console.log('No comments found or comments is not a string');\n    }\n    return {\n      statusCode: 200,\n      body: JSON.stringify(result.Item)\n    };\n  } catch (error) {\n    console.error('Error verifying transcript contents:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        message: 'Error verifying transcript',\n        error: error.message\n      })\n    };\n  }\n}\nasync function getAllCommentsForTranscript(transcriptId) {\n  try {\n    const params = {\n      TableName: 'Transcripts',\n      Key: {\n        transcriptId\n      }\n    };\n    const result = await docClient.send(new GetCommand(params));\n    let comments = [];\n    if (result.Item && result.Item.comments) {\n      try {\n        comments = JSON.parse(result.Item.comments);\n      } catch (error) {\n        console.error('Error parsing comments:', error);\n      }\n    }\n    return {\n      statusCode: 200,\n      body: JSON.stringify(comments)\n    };\n  } catch (error) {\n    console.error('Error getting comments for transcript:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        message: 'Error getting comments',\n        error: error.message\n      })\n    };\n  }\n}\nasync function uploadFileToS3(key, content) {\n  const params = {\n    Bucket: \"filesrilla\",\n    Key: key,\n    Body: Buffer.from(content, 'base64'),\n    ContentType: \"application/octet-stream\"\n  };\n  await s3Client.send(new PutObjectCommand(params));\n}\nasync function deleteFileFromS3(key) {\n  const params = {\n    Bucket: \"filesrilla\",\n    Key: key\n  };\n  await s3Client.send(new DeleteObjectCommand(params));\n}\nasync function getComment(body) {\n  // Implement this function\n}\nasync function sendTranscriptToOpenAI(data) {\n  try {\n    const response = await axios.post('YOUR_OPENAI_API_ENDPOINT', data);\n    return response;\n  } catch (error) {\n    console.error('Error sending transcript to OpenAI:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["DynamoDBClient","require","DynamoDBDocumentClient","PutCommand","GetCommand","UpdateCommand","DeleteCommand","QueryCommand","S3Client","PutObjectCommand","GetObjectCommand","DeleteObjectCommand","axios","dynamoClient","docClient","from","s3Client","region","main","event","httpMethod","body","parsedBody","JSON","parse","createComment","transcriptId","verify","verifyTranscriptContents","getAllCommentsForTranscript","commentId","getComment","statusCode","stringify","message","updateComment","deleteComment","exports","handler","userId","content","timestamp","fileAttachment","Date","now","toString","fileKey","name","uploadFileToS3","newComment","_currentTranscript$It","getParams","TableName","Key","currentTranscript","send","currentComments","Item","comments","commentsArray","error","console","push","updatedCommentsString","transcriptParams","UpdateExpression","ExpressionAttributeValues","ReturnValues","log","updateResult","comment","updateExpression","expressionAttributeValues","params","result","updatedAttributes","Attributes","deleteFileFromS3","Array","isArray","length","slice","key","Bucket","Body","Buffer","ContentType","sendTranscriptToOpenAI","data","response","post"],"sources":["/Users/hamzahdeejay/Rilla-BackEnd/rilla-app/src/index.js"],"sourcesContent":["const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');\nconst { DynamoDBDocumentClient, PutCommand, GetCommand, UpdateCommand, DeleteCommand, QueryCommand } = require('@aws-sdk/lib-dynamodb');\nconst { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } = require(\"@aws-sdk/client-s3\");\nconst axios = require('axios');\n\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\nconst s3Client = new S3Client({ region: \"us-west-1\" }); \n\nasync function main(event) {\n  const { httpMethod, body } = event;\n  const parsedBody = JSON.parse(body);\n\n  switch (httpMethod) {\n    case 'POST':\n      return await createComment(parsedBody);\n    case 'GET':\n      if (parsedBody.transcriptId && parsedBody.verify) {\n        return await verifyTranscriptContents(parsedBody.transcriptId);\n      } else if (parsedBody.transcriptId) {\n        return await getAllCommentsForTranscript(parsedBody.transcriptId);\n      } else if (parsedBody.commentId) {\n        return await getComment(parsedBody);\n      } else {\n        return {\n          statusCode: 400,\n          body: JSON.stringify({ message: 'Missing transcriptId or commentId' })\n        };\n      }\n    case 'PUT':\n      return await updateComment(parsedBody);\n    case 'DELETE':\n      return await deleteComment(parsedBody);\n    default:\n      return {\n        statusCode: 400,\n        body: JSON.stringify({ message: 'Unsupported HTTP method' })\n      };\n  }\n}\n\nexports.handler = async (event) => {\n  return await main(event);\n};\n\nasync function createComment(body) {\n  const { transcriptId, userId, content, timestamp, fileAttachment } = body;\n  \n  const commentId = Date.now().toString();\n  let fileKey;\n\n  if (fileAttachment) {\n    fileKey = `attachments/${commentId}_${fileAttachment.name}`;\n    await uploadFileToS3(fileKey, fileAttachment.content);\n  }\n\n  const newComment = {\n    commentId,\n    userId,\n    content,\n    timestamp,\n    fileAttachment: fileKey\n  };\n\n  try {\n    // Step 1: Get the current transcript\n    const getParams = {\n      TableName: 'Transcripts',\n      Key: { transcriptId }\n    };\n    const currentTranscript = await docClient.send(new GetCommand(getParams));\n    let currentComments = currentTranscript.Item?.comments || '[]';\n\n    // Parse the comments string to an array\n    let commentsArray;\n    try {\n      commentsArray = JSON.parse(currentComments);\n    } catch (error) {\n      console.error('Error parsing comments:', error);\n      commentsArray = [];\n    }\n\n    // Add the new comment\n    commentsArray.push(newComment);\n\n    // Convert the array back to a string\n    const updatedCommentsString = JSON.stringify(commentsArray);\n\n    // Step 2: Update the transcript with the new comments string\n    const transcriptParams = {\n      TableName: 'Transcripts',\n      Key: { transcriptId },\n      UpdateExpression: 'SET comments = :newComments',\n      ExpressionAttributeValues: {\n        ':newComments': updatedCommentsString\n      },\n      ReturnValues: 'UPDATED_NEW'\n    };\n\n    console.log('Updating transcript with params:', JSON.stringify(transcriptParams));\n    const updateResult = await docClient.send(new UpdateCommand(transcriptParams));\n    console.log('Transcript updated successfully. Result:', JSON.stringify(updateResult));\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Comment created and linked successfully', comment: newComment })\n    };\n  } catch (error) {\n    console.error('Error in createComment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error creating comment', error: error.message })\n    };\n  }\n}\n\nasync function updateComment(body) {\n  const { commentId, content, fileAttachment } = body;\n  \n  let updateExpression = 'set content = :c';\n  let expressionAttributeValues = { ':c': content };\n\n  if (fileAttachment) {\n    const fileKey = `attachments/${commentId}_${fileAttachment.name}`;\n    await uploadFileToS3(fileKey, fileAttachment.content);\n    updateExpression += ', fileAttachment = :f';\n    expressionAttributeValues[':f'] = fileKey;\n  }\n\n  const params = {\n    TableName: 'comments',\n    Key: { commentId },\n    UpdateExpression: updateExpression,\n    ExpressionAttributeValues: expressionAttributeValues,\n    ReturnValues: 'UPDATED_NEW'\n  };\n  \n  try {\n    const result = await docClient.send(new UpdateCommand(params));\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Comment updated successfully', updatedAttributes: result.Attributes })\n    };\n  } catch (error) {\n    console.error('Error updating comment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error updating comment', error: error.message })\n    };\n  }\n}\n\nasync function deleteComment(body) {\n  const { commentId } = body;\n  \n  const params = {\n    TableName: 'comments',\n    Key: { commentId },\n    ReturnValues: 'ALL_OLD'\n  };\n  \n  try {\n    const result = await docClient.send(new DeleteCommand(params));\n    if (result.Attributes && result.Attributes.fileAttachment) {\n      await deleteFileFromS3(result.Attributes.fileAttachment);\n    }\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: 'Comment deleted successfully' })\n    };\n  } catch (error) {\n    console.error('Error deleting comment:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error deleting comment', error: error.message })\n    };\n  }\n}\n\nasync function verifyTranscriptContents(transcriptId) {\n  const params = {\n    TableName: 'Transcripts',\n    Key: { transcriptId }\n  };\n\n  try {\n    const result = await docClient.send(new GetCommand(params));\n    console.log('Transcript contents:', JSON.stringify(result.Item, null, 2));\n    \n    if (result.Item && result.Item.comments) {\n      console.log('Comments type:', typeof result.Item.comments);\n      let commentsArray;\n      try {\n        commentsArray = JSON.parse(result.Item.comments);\n        console.log('Parsed comments is array:', Array.isArray(commentsArray));\n        console.log('Parsed comments length:', commentsArray.length);\n        console.log('First 5 comments:', commentsArray.slice(0, 5));\n      } catch (error) {\n        console.error('Error parsing comments:', error);\n        console.log('Raw comments value:', result.Item.comments);\n      }\n    } else {\n      console.log('No comments found or comments is not a string');\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify(result.Item)\n    };\n  } catch (error) {\n    console.error('Error verifying transcript contents:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error verifying transcript', error: error.message })\n    };\n  }\n}\n\nasync function getAllCommentsForTranscript(transcriptId) {\n  try {\n    const params = {\n      TableName: 'Transcripts',\n      Key: { transcriptId }\n    };\n    const result = await docClient.send(new GetCommand(params));\n    \n    let comments = [];\n    if (result.Item && result.Item.comments) {\n      try {\n        comments = JSON.parse(result.Item.comments);\n      } catch (error) {\n        console.error('Error parsing comments:', error);\n      }\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify(comments)\n    };\n  } catch (error) {\n    console.error('Error getting comments for transcript:', error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ message: 'Error getting comments', error: error.message })\n    };\n  }\n}\n\nasync function uploadFileToS3(key, content) {\n  const params = {\n    Bucket: \"filesrilla\",\n    Key: key,\n    Body: Buffer.from(content, 'base64'),\n    ContentType: \"application/octet-stream\"\n  };\n\n  await s3Client.send(new PutObjectCommand(params));\n}\n\nasync function deleteFileFromS3(key) {\n  const params = {\n    Bucket: \"filesrilla\", \n    Key: key\n  };\n\n  await s3Client.send(new DeleteObjectCommand(params));\n}\n\nasync function getComment(body) {\n  // Implement this function\n}\n\nasync function sendTranscriptToOpenAI(data) {\n  try {\n    const response = await axios.post('YOUR_OPENAI_API_ENDPOINT', data);\n    return response;\n  } catch (error) {\n    console.error('Error sending transcript to OpenAI:', error);\n    throw error;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}